{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}

module Cardano.DbSync.Era.Shelley.Offline.Query
  ( queryPoolFetchRetry
  , queryPoolHashId
  ) where

import           Cardano.Prelude hiding (from, groupBy, on, retry)

import           Cardano.DbSync.Era.Shelley.Offline.FetchQueue

import           Data.Time (UTCTime)
import qualified Data.Time.Clock.POSIX as Time

import           Cardano.Db
import qualified Cardano.Db as DB

import           Database.Esqueleto (InnerJoin (..), SqlExpr, Value (..), ValueList, desc, from,
                   groupBy, in_, just, max_, notExists, on, orderBy, select, subList_select, val,
                   where_, (==.), (^.))
import           Database.Persist.Sql (SqlBackend)


-- Get a list of the pools for which there is a PoolMetadataRef entry but there is
-- no PoolMetadata entry.
-- This is a bit questionable because it assumes that the autogenerated 'id' primary key
-- is a reliable proxy for time, ie higher 'id' was added later in time.
queryPoolFetchRetry :: MonadIO m => ReaderT SqlBackend m [PoolFetchRetry]
queryPoolFetchRetry = do
    pofe <- select . from $ \(pofe `InnerJoin` pmr `InnerJoin` ph) -> do
                on (ph ^. DB.PoolHashId ==. pmr ^. DB.PoolMetadataRefPoolId)
                on (pofe ^. DB.PoolOfflineFetchErrorPmrId ==. pmr ^. DB.PoolMetadataRefId)
                where_ (just (pofe ^. DB.PoolOfflineFetchErrorId) `in_` latestReferences)
                where_ (notExists . from $ \pod -> where_ (pod ^. DB.PoolOfflineDataPmrId ==. pofe ^. DB.PoolOfflineFetchErrorPmrId))
                orderBy [desc (pofe ^. DB.PoolOfflineFetchErrorFetchTime)]
                pure
                    ( pofe ^. DB.PoolOfflineFetchErrorFetchTime
                    , pofe ^. DB.PoolOfflineFetchErrorPmrId
                    , ph ^. DB.PoolHashView
                    , pmr ^. DB.PoolMetadataRefUrl
                    , pmr ^. DB.PoolMetadataRefHash
                    , pofe ^. DB.PoolOfflineFetchErrorRetryCount
                    , ph ^. DB.PoolHashId
                    )

    pure $ map convert pofe
  where
    latestReferences :: SqlExpr (ValueList (Maybe DB.PoolOfflineFetchErrorId))
    latestReferences =
      subList_select . from $ \ pofe -> do
        groupBy (pofe ^. DB.PoolOfflineFetchErrorPoolId, pofe ^. DB.PoolOfflineFetchErrorPoolId)
        pure $ max_ (pofe ^. DB.PoolOfflineFetchErrorId)

    convert
        :: (Value UTCTime, Value PoolMetadataRefId, Value Text, Value Text, Value ByteString, Value Word, Value PoolHashId)
        -> PoolFetchRetry
    convert (Value time, Value pmrId, Value pIdent, Value url, Value pmh, Value rCount, Value phId) =
      PoolFetchRetry
        { pfrPoolHashId = phId
        , pfrReferenceId = pmrId
        , pfrPoolIdent = PoolIdent pIdent
        , pfrPoolUrl = PoolUrl url
        , pfrPoolMDHash = PoolMetaHash pmh
        , pfrRetry = retryAgain (Time.utcTimeToPOSIXSeconds time) rCount
        }

queryPoolHashId :: MonadIO m => PoolIdent -> ReaderT SqlBackend m (Either LookupFail PoolHashId)
queryPoolHashId (PoolIdent pname) = do
    res <- select . from $ \ ph -> do
              where_ (ph ^. PoolHashView ==. val pname)
              pure (ph ^. PoolHashId)
    pure $ maybe (Left $ DbLookupMessage ("PoolHash " <> pname)) (Right . unValue) (listToMaybe res)
